<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Word Search</title>
  <style>
    body {
      background: #23253a;
      color: #222;
      font-family: 'Arial Rounded MT Bold', Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    .container {
      width: 100%;
      max-width: 440px;
      margin: 0 auto;
      padding: 0 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .top-bar {
      width: 100%;
      background: #2d314d00;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px 20px;
      box-sizing: border-box;
    }
    .game-title {
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      flex: 1;
    }
    .word-list {
      background: #f5f7fa;
      border-radius: 12px;
      margin: 20px 0 10px 0;
      padding: 16px 24px;
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: center;
      font-size: 1.2em;
      font-weight: bold;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      width: 100%;
      max-width: 400px;
      box-sizing: border-box;
    }
    .word-list span.found {
      text-decoration: line-through;
      color: #aaa;
    }
    .grid {
      position: relative;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(8, 1fr);
      font-weight: bold;
      gap: 0;
      background: #f5f7fa;
      border-radius: 12px;
      padding: 2vw;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      width: 100%;
      max-width: 400px;
      aspect-ratio: 6 / 8;
      box-sizing: border-box;
    }
    .cell {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.8em, 4vw, 2em);
      background: none;
      border-radius: 99px;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, color 0.2s;
    }
    .cell.selected {
      background: none;
      color: #131313;
      border-radius: 24px;
      box-shadow: none;
      position: relative;
      z-index: 3;
    }
    .cell.found {
      background: none;
      color: #fff;
      position: relative;
      z-index: 3;
    }
    .highlight-pill {
      position: absolute;
      background: #7be255;
      border-radius: 999px;
      opacity: 1;
      z-index: 2;
      pointer-events: none;
      transition: all 0.1s;
    }
    /* Popup styles */
    .popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .popup-overlay.active {
      visibility: visible;
      opacity: 1;
    }
    .popup-modal {
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.10);
      padding: 32px 24px 24px 24px;
      min-width: 280px;
      max-width: 90vw;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .popup-headline {
      font-size: 1.6em;
      font-weight: bold;
      color: #e6b200;
      margin-bottom: 24px;
      text-align: center;
    }
    .popup-btns {
      display: flex;
      gap: 16px;
      margin-top: 16px;
    }
    .popup-btn {
      font-size: 1.1em;
      font-weight: bold;
      border-radius: 999px;
      padding: 10px 32px;
      border: none;
      cursor: pointer;
      transition: background 0.15s, color 0.15s, border 0.15s;
    }
    .popup-btn.cta {
      background: #4CAF50;
      color: #fff;
      border: none;
      box-shadow: 0 2px 8px rgba(76,175,80,0.10);
    }
    .popup-btn.cta:active {
      background: #388e3c;
    }
    .popup-btn.outline {
      background: #fff;
      color: #4CAF50;
      border: 2px solid #4CAF50;
    }
    .popup-btn.outline:active {
      background: #e8f5e9;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <span class="game-title">Word Search</span>
    </div>
    <div class="word-list" id="wordList">
      <!-- Words will be inserted here -->
    </div>
    <div class="grid" id="grid">
      <!-- Grid will be inserted here -->
    </div>
  </div>
  <div id="levelClearedPopup" class="popup-overlay">
    <div class="popup-modal">
      <div class="popup-headline">Cleared!</div>
      <div class="popup-btns">
        <a class="popup-btn cta" href="https://start.gametize.com/" target="_blank" rel="noopener">Explore Gametize</a>
        <button class="popup-btn outline" id="restartBtn">Restart</button>
      </div>
    </div>
  </div>
  <script>
    const words = ["GAMETIZE", "TILE", "PLAYER", "POINTS", "BADGE", "QUIZ"];
    const ROWS = 8;
    const COLS = 6;

    // Directions: [rowDelta, colDelta]
    const DIRECTIONS = [
      [0, 1],    // right
      [1, 0],    // down
      [1, 1],    // down-right
      [1, -1],   // down-left
      [0, -1],   // left (reverse)
      [-1, 0],   // up (reverse)
      [-1, -1],  // up-left (reverse)
      [-1, 1],   // up-right (reverse)
    ];

    function getRandomInt(max) {
      return Math.floor(Math.random() * max);
    }

    function canPlace(grid, word, row, col, dir) {
      let [dr, dc] = dir;
      for (let i = 0; i < word.length; i++) {
        let r = row + dr * i;
        let c = col + dc * i;
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
        if (grid[r][c] !== '' && grid[r][c] !== word[i]) return false;
      }
      return true;
    }

    function placeWord(grid, word) {
      let attempts = 100;
      let wordArr = word.split('');
      if (Math.random() < 0.5) wordArr.reverse(); // Optionally reverse
      word = wordArr.join('');
      while (attempts-- > 0) {
        let dir = DIRECTIONS[getRandomInt(DIRECTIONS.length)];
        let dr = dir[0], dc = dir[1];
        let maxRow = dr === 0 ? ROWS : ROWS - dr * (word.length - 1);
        let maxCol = dc === 0 ? COLS : COLS - dc * (word.length - 1);
        let minRow = dr < 0 ? Math.abs(dr) * (word.length - 1) : 0;
        let minCol = dc < 0 ? Math.abs(dc) * (word.length - 1) : 0;
        let row = getRandomInt(maxRow - minRow) + minRow;
        let col = getRandomInt(maxCol - minCol) + minCol;
        if (canPlace(grid, word, row, col, dir)) {
          for (let i = 0; i < word.length; i++) {
            let r = row + dr * i;
            let c = col + dc * i;
            grid[r][c] = word[i];
          }
          return true;
        }
      }
      return false;
    }

    function isValidFiller(grid, r, c, ch) {
      // Check for 3 or more identical chars in row
      let row = grid[r].slice();
      row[c] = ch;
      let rowStr = row.join('');
      if (/([A-Z])\1{2,}/.test(rowStr)) return false;
      // Check for 3 or more identical chars in col
      let colArr = [];
      for (let i = 0; i < ROWS; i++) colArr.push(grid[i][c] || (i === r ? ch : ''));
      let colStr = colArr.join('');
      if (/([A-Z])\1{2,}/.test(colStr)) return false;
      return true;
    }

    function fillGrid(grid) {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!grid[r][c]) {
            let tries = 0;
            let ch;
            do {
              ch = String.fromCharCode(65 + getRandomInt(26));
              tries++;
            } while (!isValidFiller(grid, r, c, ch) && tries < 20);
            grid[r][c] = ch;
          }
        }
      }
    }

    function generateGrid() {
      let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(''));
      for (let word of words) {
        if (!placeWord(grid, word)) {
          console.warn('Could not place word:', word);
        }
      }
      fillGrid(grid);
      return grid;
    }

    // Render word list
    const wordListDiv = document.getElementById('wordList');
    words.forEach(word => {
      const span = document.createElement('span');
      span.textContent = word;
      span.id = `word-${word}`;
      wordListDiv.appendChild(span);
    });

    // Render grid
    const gridDiv = document.getElementById('grid');
    const gridData = generateGrid();
    for (let row = 0; row < ROWS; row++) {
      for (let col = 0; col < COLS; col++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.textContent = gridData[row][col];
        cell.dataset.row = row;
        cell.dataset.col = col;
        gridDiv.appendChild(cell);
      }
    }

    // Add highlight pill for selection
    const highlightPill = document.createElement('div');
    highlightPill.className = 'highlight-pill';
    gridDiv.appendChild(highlightPill);
    // Container for found word pills
    const foundPillsContainer = document.createElement('div');
    foundPillsContainer.style.position = 'absolute';
    foundPillsContainer.style.left = 0;
    foundPillsContainer.style.top = 0;
    foundPillsContainer.style.width = '100%';
    foundPillsContainer.style.height = '100%';
    foundPillsContainer.style.pointerEvents = 'none';
    gridDiv.appendChild(foundPillsContainer);

    // --- Interactivity for word selection ---
    let isSelecting = false;
    let startCell = null;
    let endCell = null;
    let selectedCells = [];
    let foundWords = new Set();
    let foundWordPills = [];
    const foundColors = ['#2196F3', '#4CAF50', '#FF9800', '#9C27B0', '#009688', '#F44336'];
    let foundColorIndex = 0;

    function getCell(row, col) {
      return document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
    }

    function getCellRect(cell) {
      const gridRect = gridDiv.getBoundingClientRect();
      const cellRect = cell.getBoundingClientRect();
      return {
        left: cellRect.left - gridRect.left,
        top: cellRect.top - gridRect.top,
        width: cellRect.width,
        height: cellRect.height
      };
    }

    function showHighlightPill(cells) {
      if (cells.length < 2) {
        highlightPill.style.display = 'none';
        return;
      }
      const first = getCellRect(cells[0]);
      const last = getCellRect(cells[cells.length - 1]);
      // Center points
      const x1 = first.left + first.width / 2;
      const y1 = first.top + first.height / 2;
      const x2 = last.left + last.width / 2;
      const y2 = last.top + last.height / 2;
      // Length and angle
      const dx = x2 - x1;
      const dy = y2 - y1;
      const length = Math.sqrt(dx * dx + dy * dy) + first.width; // add one cell width for full coverage
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      // Center position
      const centerX = (x1 + x2) / 2;
      const centerY = (y1 + y2) / 2;
      // Set pill style
      highlightPill.style.display = 'block';
      highlightPill.style.width = length + 'px';
      highlightPill.style.height = first.height * 0.9 + 'px';
      highlightPill.style.left = (centerX - length / 2) + 'px';
      highlightPill.style.top = (centerY - first.height * 0.45) + 'px';
      highlightPill.style.transform = `rotate(${angle}deg)`;
      highlightPill.style.background = foundColors[foundColorIndex % foundColors.length];
    }

    function hideHighlightPill() {
      highlightPill.style.display = 'none';
    }

    function clearSelection() {
      selectedCells.forEach(cell => cell.classList.remove('selected'));
      selectedCells = [];
      hideHighlightPill();
    }

    function getLineCells(r1, c1, r2, c2) {
      const cells = [];
      const dr = Math.sign(r2 - r1);
      const dc = Math.sign(c2 - c1);
      const len = Math.max(Math.abs(r2 - r1), Math.abs(c2 - c1));
      for (let i = 0; i <= len; i++) {
        const row = r1 + dr * i;
        const col = c1 + dc * i;
        if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
          cells.push(getCell(row, col));
        }
      }
      return cells;
    }

    function getSelectedWord(cells) {
      return cells.map(cell => cell.textContent).join('');
    }

    function getSelectedWordReverse(cells) {
      return cells.map(cell => cell.textContent).reverse().join('');
    }

    function markFound(cells, word) {
      cells.forEach(cell => cell.classList.add('found'));
      foundWords.add(word);
      const wordSpan = document.getElementById(`word-${word}`);
      if (wordSpan) wordSpan.classList.add('found');
      // Store pill info for rendering
      const r1 = parseInt(cells[0].dataset.row);
      const c1 = parseInt(cells[0].dataset.col);
      const r2 = parseInt(cells[cells.length - 1].dataset.row);
      const c2 = parseInt(cells[cells.length - 1].dataset.col);
      const color = foundColors[foundColorIndex % foundColors.length];
      foundColorIndex++;
      foundWordPills.push({ r1, c1, r2, c2, color });
      renderFoundPills();
      if (foundWords.size === words.length) {
        showLevelClearedPopup();
      }
    }

    function renderFoundPills() {
      foundPillsContainer.innerHTML = '';
      for (const pill of foundWordPills) {
        const pillDiv = document.createElement('div');
        pillDiv.className = 'highlight-pill';
        pillDiv.style.background = pill.color;
        pillDiv.style.opacity = 1;
        // Calculate pill position/size/angle
        const first = getCellRect(getCell(pill.r1, pill.c1));
        const last = getCellRect(getCell(pill.r2, pill.c2));
        const x1 = first.left + first.width / 2;
        const y1 = first.top + first.height / 2;
        const x2 = last.left + last.width / 2;
        const y2 = last.top + last.height / 2;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy) + first.width;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        pillDiv.style.width = length + 'px';
        pillDiv.style.height = first.height * 0.9 + 'px';
        pillDiv.style.left = (centerX - length / 2) + 'px';
        pillDiv.style.top = (centerY - first.height * 0.45) + 'px';
        pillDiv.style.transform = `rotate(${angle}deg)`;
        foundPillsContainer.appendChild(pillDiv);
      }
    }

    function handlePointerDown(e) {
      if (e.target.classList.contains('cell')) {
        isSelecting = true;
        startCell = e.target;
        endCell = e.target;
        clearSelection();
        startCell.classList.add('selected');
        selectedCells = [startCell];
        showHighlightPill(selectedCells);
      }
    }

    function handlePointerEnter(e) {
      if (isSelecting && e.target.classList.contains('cell')) {
        endCell = e.target;
        clearSelection();
        const r1 = parseInt(startCell.dataset.row);
        const c1 = parseInt(startCell.dataset.col);
        const r2 = parseInt(endCell.dataset.row);
        const c2 = parseInt(endCell.dataset.col);
        // Only allow straight lines
        if (r1 === r2 || c1 === c2 || Math.abs(r2 - r1) === Math.abs(c2 - c1)) {
          selectedCells = getLineCells(r1, c1, r2, c2);
          selectedCells.forEach(cell => cell.classList.add('selected'));
          showHighlightPill(selectedCells);
        } else {
          hideHighlightPill();
        }
      }
    }

    function handlePointerUp(e) {
      if (!isSelecting) return;
      isSelecting = false;
      if (selectedCells.length > 0) {
        let word = getSelectedWord(selectedCells);
        let wordRev = getSelectedWordReverse(selectedCells);
        let found = null;
        for (let w of words) {
          if (!foundWords.has(w) && (word === w || wordRev === w)) {
            found = w;
            break;
          }
        }
        if (found) {
          markFound(selectedCells, found);
        }
      }
      clearSelection();
    }

    // Attach event listeners
    gridDiv.addEventListener('pointerdown', handlePointerDown);
    gridDiv.addEventListener('pointerover', handlePointerEnter);
    window.addEventListener('pointerup', handlePointerUp);

    // --- Touch support ---
    gridDiv.addEventListener('touchstart', function(e) {
      const touch = e.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target && target.classList.contains('cell')) {
        handlePointerDown({ target });
        e.preventDefault();
      }
    }, { passive: false });

    gridDiv.addEventListener('touchmove', function(e) {
      const touch = e.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target && target.classList.contains('cell')) {
        handlePointerEnter({ target });
        e.preventDefault();
      }
    }, { passive: false });

    gridDiv.addEventListener('touchend', function(e) {
      handlePointerUp(e);
      e.preventDefault();
    }, { passive: false });

    gridDiv.addEventListener('touchcancel', function(e) {
      handlePointerUp(e);
      e.preventDefault();
    }, { passive: false });

    // Popup logic
    function showLevelClearedPopup() {
      document.getElementById('levelClearedPopup').classList.add('active');
    }
    function hideLevelClearedPopup() {
      document.getElementById('levelClearedPopup').classList.remove('active');
    }
    // Example: Uncomment to test popup
    // showLevelClearedPopup();
    document.querySelectorAll('.popup-btn.cta').forEach(btn => btn.onclick = hideLevelClearedPopup);
    document.querySelectorAll('.popup-btn.outline').forEach(btn => btn.onclick = hideLevelClearedPopup);

    function resetGame() {
      // Clear found words and pills
      foundWords.clear();
      foundWordPills.length = 0;
      foundColorIndex = 0;
      renderFoundPills();
      // Remove found/selected classes from all cells
      document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('found', 'selected');
      });
      // Remove found class from word list
      words.forEach(word => {
        const wordSpan = document.getElementById(`word-${word}`);
        if (wordSpan) wordSpan.classList.remove('found');
      });
      // Regenerate grid
      const newGrid = generateGrid();
      let i = 0;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
          if (cell) cell.textContent = newGrid[row][col];
        }
      }
      hideLevelClearedPopup();
    }
    document.getElementById('restartBtn').onclick = resetGame;
  </script>
</body>
</html>
